package logen.experimental.util.timegenerators;

import java.time.LocalTime;
import java.util.concurrent.ThreadLocalRandom;

/**
 * A skeleton implementation of the {@link TimeGenerator} interface.
 * This class implements common functionalities between and specifies
 * common fields required by time generator implementations.
 */
public abstract class AbstractTimeGenerator implements TimeGenerator {
    private static final int SECONDS_IN_MINUTE = 60;
    private static final int SECONDS_IN_HOUR = 3600;

    /**
     * The time which generation should be based on.
     * Subclasses can either use {@code fromTime} as the first time
     * value generated, or as a part of the first time value generated.
     *
     * This time should not be confused with {@code baseTime}.
     * To illustrate, imagine a line representing all the possible time
     * values generated by this.
     * {@code baseTime} would be the leftmost point on the line,
     * {@code wrapAroundTime} would be the rightmost point on the line,
     * and {@code fromTime} would be any point on the line.
     */
    protected final LocalTime fromTime;
    /**
     * The time value which generation wraps around.
     * It is effectively the latest time possibly generated.
     *
     * Time, unlike duration, does not increase or decrease indefinitely
     * without a change in precision.
     *
     * For example, in a 24 hour day, time wraps around at 23:59:59
     * since any time beyond 23:59:59 is not defined and would not make sense.
     * Hence, the wrap around time in this case is 23:59:59.
     *
     * If our day is instead 09:00:00 to 17:30:00, the wrap around time
     * would be 17:30:00 since any time beyond 17:30:00 would similarly
     * not be defined and not make sense.
     */
    protected final LocalTime wrapAroundTime;
    /**
     * The time which generation starts from after generation wraps around.
     * It is effectively the earliest time possibly generated.
     *
     * Generation cannot start from {@code fromTime} given that it does not
     * represent the earliest possible time but the time which is the result
     * of the first generation or which the first generation is based on.
     */
    protected final LocalTime baseTime;

    /**
     * The most recent time value generated.
     */
    protected LocalTime timeValue;

    protected AbstractTimeGenerator(
            LocalTime fromTime,
            LocalTime wrapAroundTime,
            LocalTime baseTime
    ) {
        this.fromTime = fromTime;
        this.wrapAroundTime = wrapAroundTime;
        this.baseTime = baseTime;
        this.timeValue = fromTime;
    }

    @Override
    public abstract LocalTime generate();

    protected static long generateRandomSeconds() {
        return ThreadLocalRandom
                .current()
                .nextLong(SECONDS_IN_MINUTE, SECONDS_IN_HOUR);
    }

    public static int computeAverageInterval() {
        return SECONDS_IN_HOUR - SECONDS_IN_MINUTE;
    }
}
