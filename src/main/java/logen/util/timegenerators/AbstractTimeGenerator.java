package logen.util.timegenerators;

import java.time.LocalTime;
import java.util.concurrent.ThreadLocalRandom;

/**
 * A skeleton implementation of the {@link TimeGenerator} interface.
 *
 * This class specifies common fields required by time generator
 * implementations, specifically a seed time for generation to start
 * from, a wrap around time and a wrap to time.
 *
 * This class also implements the common functionality of generating
 * a random number of seconds, which is useful for generating subsequent
 * time values.
 */
public abstract class AbstractTimeGenerator implements TimeGenerator {
    public static final int SMALLEST_INTERVAL_DIFFERENCE = 60;
    public static final int LARGEST_INTERVAL_DIFFERENCE = 3600;

    /**
     * The time which generation starts from.
     * Subclasses can either use {@code fromTime} as the first time
     * value generated, or in the process of generating the first time
     * value.
     *
     * This time should not be confused with {@code wrapToTime}.
     * To illustrate, imagine a line representing all the possible time
     * values generated by this.
     * Assuming the generated time values are increasing, {@code wrapToTime}
     * would be the leftmost point on the line, {@code wrapAroundTime} would
     * be the rightmost point on the line, and {@code fromTime} would be
     * any point on the line.
     */
    protected final LocalTime fromTime;
    /**
     * The time which generation wraps around.
     * It is effectively the latest time possibly generated.
     *
     * Time, unlike duration, does not increase or decrease indefinitely
     * without a change in precision.
     *
     * For example, in a 24 hour day, time wraps around at 23:59:59
     * since any time beyond 23:59:59 is not defined and would not make sense.
     * Hence, the wrap around time in this case is 23:59:59.
     *
     * If our day is instead 09:00:00 to 17:30:00, the wrap around time
     * would be 17:30:00 since any time beyond 17:30:00 would similarly
     * not be defined and not make sense.
     */
    protected final LocalTime wrapAroundTime;
    /**
     * The time which generation starts from after generation wraps around.
     * It is effectively the earliest time possibly generated.
     *
     * After generation wraps around, generation cannot start from
     * {@code fromTime} given that it does not represent the earliest possible
     * time.
     */
    protected final LocalTime wrapToTime;

    /**
     * The most recent time value generated.
     */
    protected LocalTime timeValue;

    protected AbstractTimeGenerator(
            LocalTime fromTime,
            LocalTime wrapAroundTime,
            LocalTime wrapToTime
    ) {
        this.fromTime = fromTime;
        this.wrapAroundTime = wrapAroundTime;
        this.wrapToTime = wrapToTime;
        this.timeValue = fromTime;
    }

    @Override
    public abstract LocalTime generate();

    protected static long generateRandomSeconds() {
        return ThreadLocalRandom
                .current()
                .nextLong(SMALLEST_INTERVAL_DIFFERENCE, LARGEST_INTERVAL_DIFFERENCE + 1);
    }

    public static int computeInterval() {
        return LARGEST_INTERVAL_DIFFERENCE - SMALLEST_INTERVAL_DIFFERENCE;
    }
}
