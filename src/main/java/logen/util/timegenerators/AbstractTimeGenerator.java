package logen.util.timegenerators;

import java.time.LocalTime;
import java.util.concurrent.ThreadLocalRandom;

/**
 * A skeleton implementation of the {@link TimeGenerator} interface.
 * This class implements common functionalities between and specifies
 * common fields required by time generator implementations.
 */
public abstract class AbstractTimeGenerator implements TimeGenerator {
    public static final int SMALLEST_INTERVAL_DIFFERENCE = 60;
    public static final int LARGEST_INTERVAL_DIFFERENCE = 3600;

    /**
     * The time which generation should be based on.
     * Subclasses can either use {@code fromTime} as the first time
     * value generated, or as a part of the first time value generated.
     *
     * This time should not be confused with {@code wrapToTime}.
     * To illustrate, imagine a line representing all the possible time
     * values generated by this.
     * {@code wrapToTime} would be the leftmost point on the line,
     * {@code wrapAroundTime} would be the rightmost point on the line,
     * and {@code fromTime} would be any point on the line.
     */
    protected final LocalTime fromTime;
    /**
     * The time value which generation wraps around.
     * It is effectively the latest time possibly generated.
     *
     * Time, unlike duration, does not increase or decrease indefinitely
     * without a change in precision.
     *
     * For example, in a 24 hour day, time wraps around at 23:59:59
     * since any time beyond 23:59:59 is not defined and would not make sense.
     * Hence, the wrap around time in this case is 23:59:59.
     *
     * If our day is instead 09:00:00 to 17:30:00, the wrap around time
     * would be 17:30:00 since any time beyond 17:30:00 would similarly
     * not be defined and not make sense.
     */
    protected final LocalTime wrapAroundTime;
    /**
     * The time which generation starts from after generation wraps around.
     * It is effectively the earliest time possibly generated.
     *
     * After generation wraps around, generation cannot start from
     * {@code fromTime} given that it does not represent the earliest possible
     * time.
     */
    protected final LocalTime wrapToTime;

    /**
     * The most recent time value generated.
     */
    protected LocalTime timeValue;

    protected AbstractTimeGenerator(
            LocalTime fromTime,
            LocalTime wrapAroundTime,
            LocalTime wrapToTime
    ) {
        this.fromTime = fromTime;
        this.wrapAroundTime = wrapAroundTime;
        this.wrapToTime = wrapToTime;
        this.timeValue = fromTime;
    }

    @Override
    public abstract LocalTime generate();

    protected static long generateRandomSeconds() {
        return ThreadLocalRandom
                .current()
                .nextLong(SMALLEST_INTERVAL_DIFFERENCE, LARGEST_INTERVAL_DIFFERENCE + 1);
    }

    public static int computeInterval() {
        return LARGEST_INTERVAL_DIFFERENCE - SMALLEST_INTERVAL_DIFFERENCE;
    }
}
