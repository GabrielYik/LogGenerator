:appName: LogGenerator

= LogGenerator - Developer Guide
:toc:
:toclevels: 3
:sectnums:
:sectnumlevels: 3

== Introduction
This guide details the specification, development and implementation of `{appName}`.

== Motivation
A project required that security logs be created for examination purposes, namely to
test if an individual is able to shift through logs to spot exploits.
The initial intention was to create these logs manually.
However, this approach is tedious and potentially error-prone.

As such, a decision was made to automate the generation of logs.
The benefits were clear:

* A large number of logs can be generated easily
* Characteristics of the logs to be generated can be specified
* Changes made to the characteristics of specific types of logs can be propagated
consistently throughout if required

The application developed to automate the generation of logs is aptly named `{appName}`.

== Scenario
* A series of actions acting on a software system.
* The attributes of a scenario are configurable through a configuration file.

=== Attributes
There are three levels of scenario attributes.

[cols="2, 5"]
.Scenario Attributes
|===
|Type |Description

|Global
|Applies to all logs.

|Group
|Applies to some logs.

|Local
|Applies to an individual log.
|===

This separation of scope allows for the fine-grained configuration of a scenario.

==== Global
[cols="2, 5, 5a"]
.Global Scenario Attributes
|===
|Attribute |Description |Settings

|Number of Logs
|The minimum number of logs.
|
* minLogCount
** Options: any positive integer
** Default: 200

|Headers
|The description of all attributes of a log.

The attributes of a log are described in <<log_structure, Log Structure>>.
|
* headers
** Options: a non-empty array of strings
** Default: [time, description, type, subject, remark]
** Each string describes an attribute of a log
** Each description should be succinct for readability

|Time Period
|The value range of the time attribute of all logs.
|
* timePeriod
** startTime
*** Options: a time between 00:00:00 and 23:59:59
*** Default: 09:00:00
*** The start time must be before the end time
** endTime
*** Options: a time between 00:00:00 and 23:59:59
*** Default: 17:00:00
*** The end time must be after the start time

|Descriptions
|The value range of the description attribute of all logs.
|
* descriptions
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a description

|Types
|The value range of the type attribute of all logs.
|
* types
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a type

|Subjects
|The value range of the subject attribute of all logs.
|
* subjects
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a subject

|Remarks
|The value range of the remark attribute of all logs.
|
* remarks
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a remark

|Frequency
|The frequency in which all logs appear.
|
* frequency
** type
*** Options: ANY, CUSTOM
*** Default: none
** count (if type is CUSTOM)
*** Options: Any positive integer
*** Default: none
|===

==== Group
Attributes defined at the group level take precedence over the same attributes (singular
or plural) defined at the global level.

[cols="2, 5, 5a"]
.Group Scenario Attributes
|===
|Attribute |Description |Settings

|Ordering
|The sequence in which logs in the group are to be placed.
|
* ordering
** type
*** Options: ANY, CUSTOM
*** Default: ANY
** positions (if type is CUSTOM)
*** Options: a non-empty array of the integers 1 to n
*** Default: a random permutation of the integers 1 to n
*** n refers to the number of log specifications in the group
*** Each integer specifies the position of the corresponding log specification
*** E.g. in a group of 4 logs, [1, 2, 3, 4] means that the first log will be placed
first, the second log second, and so forth
*** E.g. in a group of 4 logs, [3, 2, 1, 4] means that the first log will be placed
third, the second log second, the third log first and the fourth log fourth.

|Spacing
|The number of logs between two specified logs in the group.
|
* spacing
** type
*** Options: ANY, CUSTOM
*** Default: ANY
** amount (if type is CUSTOM)
*** Options: a non-empty array of non-negative integers of size n - 1
*** Default: none
*** n refers to the number of log specifications in the group
*** E.g. in a group of 4 logs, [0, 0, 0] means that there are 0 logs between the first
and second log, 0 logs between the second and third log, and so on.
*** E.g. in a group of 4 logs, [1, 2, 0] means that there is 1 log between the first and
second log, 2 logs between the second and third log, and 0 logs between the third and
fourth log

|Time Period
|The constraint on the value of the time attribute of a log in the group.
|
* timePeriod
** type
*** Options: ANY, CUSTOM, ONE HOUR, ONE DAY, AFTER MIDNIGHT
*** Default: ANY
** startTime (if type is *NOT* ANY)
*** Options: a time between 00:00:00 and 23:59:59
*** Default: 09:00:00
*** The start time must be before the end time
** endTime (if type is *NOT* ANY)
*** Options: a time between 00:00:00 and 23:59:59
*** Default: 17:00:00
*** The end time must be after the start time

|Descriptions
|The value range of the description attribute of a log in the group.
|
* descriptions
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a description

|Types
|The value range of the type attribute of a log in the group.
|
* types
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a type

|Subjects
|The value rang of the subject attribute of a log in the group.
|
* subjects
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a subject

|Remarks
|The value range of the remark attribute of a log in the group.
|
* remarks
** Options: a non-empty array of non-empty strings
** Default: none
** Each string represents a remark

|Frequency
|The frequency in which all the logs in the group appear.
|
* frequency
** type
*** Options: ANY, CUSTOM
*** Default: none
** count (if type is CUSTOM)
*** Options: Any positive integer
*** Default: none
|===

==== Local
Attributes defined at the local level take precedence over the same attributes (singular
or plural) defined at the global and group levels.

[cols="2, 5, 5a"]
.Local Scenario Attributes
|===
|Attribute |Description |Settings

|Description
|The value of the description attribute of the log.
|
* description
** Options: any non-empty string
** Default: none

|Type
|The value of the category attribute of the log.
|
* type
** Options: any non-empty string
** Default: none

|Subject
|The value of the subject attribute of the log.
|
* subject
** Options: any non-empty string
** Default: none

|Remark
|The value of the remark attribute of the log.
|
* remark
** Options: any non-empty string
** Default: none

|Frequency
|The frequency at which a log appears.
|
* type
** Options: ANY, CUSTOM
** Default: ANY
* count (if type is CUSTOM)
** Options: any positive integer
** Default: none
|===

=== Exploits
* An exploit is a subset of a scenario.
* An exploit occurs due to a perpetrator, or a group of perpetrators that took advantage
of security anomalies or vulnerabilities in a software system.

==== Design
There is no formula to designing an exploit.

In reality, exploits can range from relatively simple operations like taking advantage
of a lack of restrictions in accessing a company's admin system to more complex
operations like taking advantage of assumptions and lack of coordination taken by
various entities in implementing an e-commerce system.

As such, `{appName}` does not aim to completely capture the characteristics of an
exploit, but through the various configurable scenario attributes, provide enough
power to exploit designers to design an exploit representable in logs.

== Log
* A record which captures an action acting on a software system.
* Has attributes such as the time and description of the action captured.
* A set of logs is a log sheet.

[[log_structure]]
=== Structure
[cols="2, 5"]
.Log Structure
|===
|Attribute |Description

|Time
|The creation time of the log.

|Description
|The action captured by the log.

Some examples include the login of a user and the deletion of a file.

|Type
|The category of the log.

Some examples include access control and file retrieval.

|Subject
|The subject of the log.

This refers to an entity like a human user or computer user.
If no subject is specified, one of the subjects specified in the global subjects
attribute is used.

|Remark
|Any additional information about the log.

Some examples include whether the action taken was successful and the amount of memory
allocated to a process.
|===

=== Types
There are different types of logs.
Conceptually, they can be categorised a one way: exploit and non-exploit.
However, this categorisation does not carry well into implementation, and another
categorisation is used instead: fixed and filler.
In both cases, there are no differences in the structure of the logs.

==== Exploit and Non-exploit
Conceptually, there are two types of logs: exploit and non-exploit.

Exploit logs capture the actions of an exploit in a scenario.
Observing what exploit logs are present serve to help the observing party understand
what kind of exploit is captured in the scenario, and how the exploit is conducted.

Non-exploit logs represent the other actions in a scenario.
Non-exploit logs serve to make the scenario more realistic and make the exploit logs
more difficult to find.

===== Relationship to Scenario Attributes
Exploit and non-exploit logs have no scenario attributes that make them what they are.
What makes an exploit log exploit, and a non-exploit log non-exploit is the intention of
the exploit designer.

==== Fixed and Filler
For implementation, there are two types of logs: fixed and filler.

Imagine a log sheet as a long horizontal line.

Fixed logs are logs have regions or positions on the line assigned to them.
This is due to constraints imposed on these logs.
The possible constraints are the ordering, spacing and time period scenario group attributes.
Hence, fixed logs are logs that are defined in groups and have the aforementioned
attributes specified.

Now, imagine a log sheet with the fixed logs in place. There are still gaps in between
these fixed logs. This is where filler logs come in.

Filler logs are the opposite of fixed logs in that they can be placed anywhere on the
line.
Filler logs fill the spaces which are left by fixed logs.

===== Relationship to Scenario Attributes
Fixed logs are defined by the configuration of any of the following scenario group
attributes: ordering, spacing, time period and to a certain extent, frequency.
On their own, the attributes ordering, spacing and time period make the logs fixed.
However, the configuration of frequency on its own does make a log fixed; it has to be
configured with any of the aforementioned attributes.

== Architecture

=== Approach

==== Problem
Given that at the implementation level, there are two types of logs: fixed and filler,
we can base the architecture on the generation of these two types of logs.
However, a choice has to be made on the order of generation.

==== Solutions
There are three approaches:

. Generate fixed logs before filler logs
. Generate filler logs before fixed logs
. Generate fixed and filler logs together

==== Criteria
To decide between the three approaches, we consider three criterions:

* Ease of understanding
* Ease of implementation

==== Evaluation
[cols="2, 5a, 5, 5a"]
.Comparisons
|===
|Criterion |Fixed then Filler |Filler then Fixed |Fixed and Filler

|Ease of understanding
|Good
|Good
|Could be confusing

With both fixed and filler logs being generated at the same time, there is a need to
coordinate the respective generations.

|Ease of implementation
|Good
|Could be complicated

Fixed logs being generated after filler logs would not fit their namings.
Nonetheless, it could be done.
There could be gaps placed between filler logs for the fixed logs to be inserted into.
|Could be complicated

Like the point made on ease of understanding, there has to be coordination between the
generation of both types of logs.
|===

==== Conclusion
The approach of generating fixed logs before filler logs is the best given its
satisfaction of both criterion.
