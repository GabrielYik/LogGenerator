:appName: LogGenerator

= LogGenerator - Developer Guide
:toc:
:toclevels: 3
:sectnums:
:sectnumlevels: 3

== Introduction
This guide details the specification, development and implementation of `{appName}`.

== Motivation
A project required that security logs be created for examination purposes, namely to
test if an individual is able to shift through logs to spot exploits.
The initial intention was to create these logs manually.
However, this approach is tedious and potentially error-prone.

As such, a decision was made to automate the generation of logs.
The benefits were clear:

* Many logs can be generated easily
* Characteristics of the logs generated can be specified
* Changes made to the characteristics of specific types of logs can be propagated
consistently throughout if required

The application developed to automate the generation of logs is aptly named `{appName}`.

== Scenario
* A series of actions acting on a software system.
* The attributes of a scenario are configurable through a configuration file.

=== Attributes
There are three types of scenario attributes.

[cols="2, 5"]
.Scenario Attributes
|===
|Type |Description

|Global
|Applies to the log sheet and all logs in it.

|Group
|Applies to some logs.

|Local
|Applies to an individual log.
|===

This separation of scope allows for the fine-grained configuration of the scenario.

==== Global
[cols="2, 5, 5a"]
.Global Scenario Attributes
|===
|Attribute |Description |Settings

|Log Count
|The number of logs in the log sheet.
|
* logCount
** Any positive integer

|Headers
|The description of the columns in the log sheet.
|
* headers
** An array of strings, with each string describing an attribute of a log
** Each description should be succinct for readability

|Time Period
|The range of values the time attribute of a log in the log sheet can take.
|
* type
** One of the following: WEEKDAY, WEEKEND, EVERY DAY
* startTime
** A time between 00:00:00 and 23:59:59
** The start time must be before the end time
* endTime
** A time between 00:00:00 and 23:59:59
** The end time must be after the start time
* specifics
** day
*** One of the following: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
** startTime
*** A time between 00:00:00 and 23:59:59
*** The start time must be before the end time
** endTime
*** A time between 00:00:00 and 23:59:59
*** The end time must be after the start time

|Subjects
|The range of values the subject attribute of a log in the log sheet can take.
|
* subjects
** An array of non-empty strings, with each string representing a subject
|===

==== Group
[cols="2, 5, 5a"]
.Group Scenario Attributes
|===
|Attribute |Description |Settings

|Identifier
|The identifier of the group.
|
* identifier
** Any string

|Order
|The sequence in which the logs in the group in relation to each other should be placed
in the log sheet
|
* order
** An array of positive integers, with each integer specifying the position of the
corresponding log specification
** There must be the same number of values as logs in the group
** E.g. in a group of 4 logs, [1, 2, 3, 4] means that the first log will be placed
first, the second log second, and so forth
** E.g. in a group of 4 logs, [3, 2, 1, 4] means that the first log will be placed
third, the second log second, the third log first and the fourth log fourth.

|Space
|The number of logs between two specified logs in the group.
|
* type
** ANY, CUSTOM
* amount
** An array of non-negative integers
** There must be one less integer than logs in the group
** E.g. in a group of 4 logs, [0, 0, 0] means that there are 0 logs between the first
and second log, 0 logs between the second and third log, and so on.
** E.g. in a group of 4 logs, [1, 2, 0] means that there is 1 log between the first and
second log, 2 logs between the second and third log, and 0 logs between the third and
fourth log

|Time Period
|The constraint on the value the time attribute of a log in the group in relation to
each other can take
|
* type
** ANY, CUSTOM, ONE HOUR, ONE DAY, AFTER MIDNIGHT
* startTime
** A time between 00:00:00 and 23:59:59
** The start time must be before the end time
* endTime
** A time between 00:00:00 and 23:59:59
** The end time must be after the start time

|Description
|The value of the description attribute of all logs in the group.
|
* description
** Any string

|Type
|The value of the type attribute of all logs in the group.
|
* type
** Any non-empty string

|Subject
|The value of the subject attribute of all log in the group.
|
* subject
** Any non-empty string

|Remarks
|The value of the remarks attribute of all log in the group.
|
* remarks
** Any string

|Frequency
|The frequency in which all the logs in the group appear in the log sheet.
|
* type
** ANY, CUSTOM
* count
** Any positive integer
|===

==== Local
[cols="2, 5, 5a"]
.Local Scenario Attributes
|===
|Attribute |Description |Settings

|Description
|The value of the description attribute of the log.
|
* description
** Any string

|Type
|The value of the category attribute of the log.
|
* type
** Any non-empty string

|Subject
|The value of the subject attribute of the log.
|
* subject
** Any non-empty string

|Remarks
|The value of the remarks attribute of the log.
|
* remarks
** Any string

|Frequency
|The frequency at which a log appears in the log sheet.
|
* type
** ANY, CUSTOM
* count
** Any positive integer
|===

=== Exploits
* An exploit is a subset of a scenario.
* An exploit occurs due to a perpetrator, or a group of perpetrators that took advantage
of security anomalies or vulnerabilities in a software system.

==== Design
There is no formula to designing an exploit.

In reality, exploits can range from relatively simple operations like taking advantage
of a lack of restrictions in accessing a company's admin system to more complex
operations like taking advantage of assumptions and lack of coordination taken by
various entities in implementing an e-commerce system.

As such, `{appName}` does not aim to completely capture the characteristics of an
exploit, but through the various configurable scenario attributes, provide enough
power to exploit designers to design an exploit representable in logs.

== Logs
* A record which captures an action acting on a software system.
* Has attributes such as the time and description of the action captured.
* A set of logs is a log sheet.
* A log sheet has a set of headers where each header represents an attribute of the log.

=== Structure
[cols="2, 5"]
.Log Structure
|===
|Attribute |Description

|Time
|The creation time of the log.

|Description
|The action captured by the log.

Some examples include the login of a user and the deletion of a file.

|Type
|The category of the log.

Some examples include access control and file retrieval.

|Subject
|The subject of the log.

This refers to an entity like a human user or computer user.
If no subject is specified, one of the subjects specified in the global subjects
attribute is used.

|Remarks
|Any additional information about the log.

Some examples include whether the action taken was successful and the amount of memory
allocated to a process.
|===

=== Types
There are different types of logs.
Conceptually, they can be categorised a one way.
However, this categorisation does not carry well into implementation, and another
categorisation is used instead.
In both cases, there are no differences in structure of the logs.

==== Exploit and Non-exploit
Conceptually, there are two types of logs: exploit and non-exploit.

Exploit logs capture the actions of an exploit in a scenario.
Observing what exploit logs are present serve to help the observing party understand
what kind of exploit is captured in the scenario, and how the exploit is conducted.

Non-exploit logs represent the other actions in a scenario.
Non-exploit logs serve to make the scenario more realistic and make the exploit logs
more difficult to find.

===== Relationship to Scenario Attributes
Exploit and non-exploit logs have no scenario attributes that make them what they are.
What makes an exploit log exploit, and a non-exploit log non-exploit is the intention of
the exploit designer.

==== Fixed and Filler
For implementation, there are two types of logs: fixed and filler.

Imagine a log sheet as a long horizontal line.

Fixed logs are logs have regions or positions on the line assigned to them.
This is due to constraints imposed on these logs.
The possible constraints are the order, space and time period scenario group attributes.
Hence, fixed logs are logs that are defined in groups and have the aforementioned
attributes specified.

Now, imagine a log sheet with the fixed logs in place. There are still gaps in between
these fixed logs. This is where filler logs come in.

Filler logs are the opposite of fixed logs in that they can be placed anywhere on the
line.
Filler logs fill the spaces which are left by fixed logs.

===== Relationship to Scenario Attributes
Fixed logs are defined by the configuration of any of the following scenario group
attributes: order, space, time period and to a certain extent, frequency.
On their own, the attributes order, space and time period make the logs fixed.
However, the configuration of frequency on its own does make a log fixed; it has to be
configured with any of the aforementioned attributes.

== Architecture

=== Approach
Among all the scenario attributes, only the time period group attribute is difficult to
implement. As such, the ease of implementation of this attribute must be considered in
deciding the best approach to development.

Since there are two types of logs: exploit and noise, development could be done in three
approaches:

. Exploit then noise
. Noise then exploit
. Exploit and noise together

To decide between these three approaches, three criterions are considered:

* Complexity of implementation
* Cohesiveness
* Adherence to scenario

=== Exploit then Noise

==== Overview
Exploit logs are generated before exploit logs.

==== Implementation
Exploit logs are generated first. There are three constraints on exploit logs to
consider: order, space and time.

Order is the simplest to resolve. If there is only a single group, the logs are ordered
as specified. If there is more than one group, the ordering between two logs from two
different groups is not specified and hence can be in any order. If there are no groups,
no ordering is needed.

Space is resolved by putting placeholders between the logs. These placeholders would
contain details about how many logs are needed between the two logs.

Time is not entirely straightforward to resolve. If there are specific time constraints
on the group like 1AM to 5AM, these are applied to the time values of the logs. Then,
we insert placeholders before the first and after the last exploit log. These
placeholders detail how many logs are needed in those areas.

Now it's time to generate the noise logs. Currently, we have our exploit logs with their
constraints resolved, and with placeholders between and around them as required. The
generation of the noise logs need only follow the details of the placeholders. For the
first placeholder (before the first exploit log), the time values of the noise logs have
to be generated backwards to ensure that the timings are consistent.

==== Evaluation
|===
|Criterion |Evaluation

|Complexity of implementation
|Flow of control linear from generating fixed logs to fluid logs.

|Cohesiveness
|Separation of concerns between generating fixed logs and fluid logs.

|Adherence to scenario
|Exact.
|===

=== Noise then Exploit

==== Overview
Noise logs are generated before exploit logs.

==== Implementation
However, the
time values of the noise logs cannot be generated before injection of exploit logs since
the injection of exploit logs would require changes in the time values of surrounding
noise logs to maintain realistic time values throughout. Furthermore, if exploit logs
are constrained by a time constraint, the noise logs would most likely require a rework
of their time values.

Instead, we could generate the noise logs without time values, then inject the exploit
logs with time values, then set the time values of the noise logs from there. If say
the first exploit log has a time value of 1am, then the previous noise log would be
around 5pm (assuming 5pm is the end time for all logs). If the first exploit log has a
time value of 2pm (within the start and end time for all logs), the previous noise log
would be an amount of time before that.

We could also generate noise logs to fill the entire log sheet, with time values, and
replace individual noise logs where required with exploit logs. However, this might lead
to a situation with more logs than is specified since some exploit logs may have time
constraints that specify that their time values should be outside of the time set
globally.

==== Evaluation
|===
|Criterion |Evaluation

|Complexity of implementation
|Flow of control almost linear from fixed logs to fluid to fixed

|Cohesiveness
|Some criss-crossing of control

|Adherence to scenario
|Might not when injecting fixed logs into the log sheet
|===

=== Noise and Exploit

==== Overview
Noise and exploit logs are generated together.

==== Implementation
Some noise logs will be generated
first, but when it comes to a time when exploit logs have to be generated, noise log
generation will stop and transfer control to exploit log generation.

This requires checks for every log generation and is inefficient.

==== Evaluation
|===
|Criterion |Evaluation

|Complexity of implementation
|Flow of control criss crosses here and there

|Cohesiveness
|

|Adherence to scenario
|Exact
|===
